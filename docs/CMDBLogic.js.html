<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: CMDBLogic.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: CMDBLogic.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file CMDBLogic.js
 * @description
 * Capa de lógica de negocio y persistencia para la CMDB de películas.
 * Gestiona:
 *  - Migración de claves antiguas de LocalStorage
 *  - CRUD de géneros y películas
 *  - Validaciones según requisitos (a–e)
 *  - Sistema de votaciones
 *
 * Exporta la API pública en window.CMDBLogic para uso desde app.js.
 *
 * @author
 * Miguel Garcia
 * @version 1.0.1
 */

/**
 * @constant {string} GENRES_KEY - Clave principal de géneros en LocalStorage.
 */
const GENRES_KEY = "genres";
/**
 * @constant {string} MOVIES_KEY - Clave principal de películas en LocalStorage.
 */
const MOVIES_KEY = "movies";
/**
 * @constant {string} OLD_GENRES_KEY - Clave antigua (compatibilidad).
 */
const OLD_GENRES_KEY = "cmdb_genres";
/**
 * @constant {string} OLD_MOVIES_KEY - Clave antigua (compatibilidad).
 */
const OLD_MOVIES_KEY = "cmdb_movies";

/**
 * Representa un género del sistema.
 * @typedef {Object} Genre
 * @property {number} id - Identificador único autoincremental.
 * @property {string} name - Nombre del género.
 */

/**
 * Representa una película del sistema.
 * @typedef {Object} Movie
 * @property {number} id - Identificador único autoincremental.
 * @property {string} title - Título de la película.
 * @property {string} releaseDate - Fecha YYYY-MM-DD.
 * @property {number} popularity - Popularidad 0..100.
 * @property {number[]} genres - IDs de géneros asociados.
 * @property {number[]} puntuaciones - Valoraciones 0..10.
 * @property {number} votes - Total de votos.
 * @property {string} score - Media redondeada sin decimales.
 */

/**
 * Migración: si hay datos en cmdb_* y no en claves originales,
 * los copia a las claves originales.
 *
 * @returns {void}
 */
function migrateOldKeysIfNeeded() {
  const oldGenres = JSON.parse(localStorage.getItem(OLD_GENRES_KEY) || "null");
  const oldMovies = JSON.parse(localStorage.getItem(OLD_MOVIES_KEY) || "null");

  const currentGenres = JSON.parse(localStorage.getItem(GENRES_KEY) || "null");
  const currentMovies = JSON.parse(localStorage.getItem(MOVIES_KEY) || "null");

  if (!currentGenres &amp;&amp; oldGenres) {
    localStorage.setItem(GENRES_KEY, JSON.stringify(oldGenres));
  }
  if (!currentMovies &amp;&amp; oldMovies) {
    localStorage.setItem(MOVIES_KEY, JSON.stringify(oldMovies));
  }
}

/**
 * Recupera el array de géneros desde LocalStorage.
 *
 * @returns {Genre[]} Lista de géneros.
 */
function getGenres() {
  migrateOldKeysIfNeeded();
  return JSON.parse(localStorage.getItem(GENRES_KEY)) || [];
}

/**
 * Guarda el array de géneros en LocalStorage.
 *
 * @param {Genre[]} genres - Lista de géneros a persistir.
 * @returns {void}
 */
function saveGenres(genres) {
  localStorage.setItem(GENRES_KEY, JSON.stringify(genres));
}

/**
 * Recupera el array de películas desde LocalStorage.
 * ✅ Migra ratings -> puntuaciones
 * ✅ Recalcula siempre votes y score a partir de puntuaciones
 *
 * @returns {Movie[]} Lista de películas.
 */
function getMovies() {
  migrateOldKeysIfNeeded();
  const movies = JSON.parse(localStorage.getItem(MOVIES_KEY)) || [];

  let changed = false;

  movies.forEach(m => {
    // ✅ migración automática ratings -> puntuaciones
    if (!m.puntuaciones &amp;&amp; m.ratings) {
      m.puntuaciones = m.ratings;
      delete m.ratings;
      changed = true;
    }

    if (!Array.isArray(m.puntuaciones)) {
      m.puntuaciones = [];
      changed = true;
    }

    // ✅ recalcular siempre votos y puntuación desde puntuaciones
    m.votes = m.puntuaciones.length;

    if (m.votes > 0) {
      const avg = m.puntuaciones.reduce((a, b) => a + b, 0) / m.votes;
      m.score = String(Math.round(avg)); // sin decimales
    } else {
      m.score = "0";
    }
  });

  if (changed) saveMovies(movies);

  return movies;
}

/**
 * Guarda el array de películas en LocalStorage.
 *
 * @param {Movie[]} movies - Lista de películas a persistir.
 * @returns {void}
 */
function saveMovies(movies) {
  localStorage.setItem(MOVIES_KEY, JSON.stringify(movies));
}

/**
 * Asegura que existe el género "género desconocido".
 * Si no existe, lo crea con id autoincremental.
 *
 * @returns {void}
 */
function ensureUnknownGenre() {
  const genres = getGenres();
  const exists = genres.some(g => g.name.toLowerCase() === "género desconocido");
  if (!exists) {
    const newId = genres.length ? Math.max(...genres.map(g => g.id)) + 1 : 1;
    genres.push({ id: newId, name: "género desconocido" });
    saveGenres(genres);
  }
}

function initStarWarsSeedIfEmpty() {
  ensureUnknownGenre();

  const existingMovies = getMovies();
  const existingGenres = getGenres();

  if (existingMovies.length > 0 || existingGenres.length > 1) return;

  const genreNames = ["Acción", "Ciencia ficción", "Aventura", "Fantasía"];
  let genres = getGenres();

  function getOrCreateGenreId(name) {
    let g = genres.find(x => x.name.toLowerCase() === name.toLowerCase());
    if (!g) {
      const newId = genres.length
        ? Math.max(...genres.map(x => x.id)) + 1
        : 1;
      g = { id: newId, name };
      genres.push(g);
    }
    return g.id;
  }

  const genreIds = {};
  genreNames.forEach(n => (genreIds[n] = getOrCreateGenreId(n)));
  saveGenres(genres);

  const starWarsMovies = [
    {
      title: "Star Wars: Episodio I - La amenaza fantasma",
      releaseDate: "1999-05-19",
      popularity: 78.5,
      genres: [genreIds["Acción"], genreIds["Ciencia ficción"], genreIds["Aventura"]]
    },
    {
      title: "Star Wars: Episodio II - El ataque de los clones",
      releaseDate: "2002-05-16",
      popularity: 74.2,
      genres: [genreIds["Acción"], genreIds["Ciencia ficción"], genreIds["Aventura"]]
    },
    {
      title: "Star Wars: Episodio III - La venganza de los Sith",
      releaseDate: "2005-05-19",
      popularity: 86.9,
      genres: [genreIds["Acción"], genreIds["Ciencia ficción"], genreIds["Aventura"], genreIds["Fantasía"]]
    },
    {
      title: "Star Wars: Episodio IV - Una nueva esperanza",
      releaseDate: "1977-05-25",
      popularity: 95.0,
      genres: [genreIds["Acción"], genreIds["Ciencia ficción"], genreIds["Aventura"], genreIds["Fantasía"]]
    },
    {
      title: "Star Wars: Episodio V - El Imperio contraataca",
      releaseDate: "1980-05-21",
      popularity: 98.0,
      genres: [genreIds["Acción"], genreIds["Ciencia ficción"], genreIds["Aventura"]]
    }
  ];

  let nextId = 1;
  const movies = starWarsMovies.map(m => ({
    id: nextId++,
    title: m.title,
    releaseDate: m.releaseDate,
    popularity: m.popularity,
    genres: m.genres,
    puntuaciones: [],
    votes: 0,
    score: "0"
  }));

  saveMovies(movies);
}

/**
 * Añade un género nuevo o actualiza uno existente.
 *
 * @param {string} name - Nombre del género.
 * @param {number|null} [idEditing=null] - ID del género si se edita. Null si es alta.
 * @returns {{ok:boolean, msg?:string}} Resultado de la operación.
 */
function addOrUpdateGenreLogic(name, idEditing = null) {
  const cleanName = name.trim();
  if (!cleanName) return { ok: false, msg: "El género no puede estar vacío." };

  const genres = getGenres();

  const dup = genres.some(g =>
    g.name.toLowerCase() === cleanName.toLowerCase() &amp;&amp;
    g.id !== idEditing
  );
  if (dup) return { ok: false, msg: "Ese género ya existe." };

  if (idEditing == null) {
    const newId = genres.length ? Math.max(...genres.map(g => g.id)) + 1 : 1;
    genres.push({ id: newId, name: cleanName });
  } else {
    const idx = genres.findIndex(g => g.id === idEditing);
    if (idx === -1) return { ok: false, msg: "Género no encontrado." };
    genres[idx].name = cleanName;
  }

  saveGenres(genres);
  return { ok: true };
}

/**
 * Elimina un género SOLO si no está asociado a películas.
 *
 * @param {number} id - ID del género.
 * @returns {{ok:boolean, msg?:string}} Resultado.
 */
function deleteGenreLogic(id) {
  const movies = getMovies();

  // ✅ fix defensivo por si m.genres es undefined
  const usedInMovies = movies.some(m => (m.genres || []).includes(id));

  if (usedInMovies) {
    return {
      ok: false,
      msg: "No puedes eliminar este género: hay películas que lo usan. Primero quítalo en esas películas."
    };
  }

  const genres = getGenres().filter(g => g.id !== id);
  saveGenres(genres);
  return { ok: true };
}

/**
 * Valida datos de una película según criterios.
 *
 * @param {{id:number|null,title:string,releaseDate:string,popularity:number,genres:number[]}} movie
 * @returns {string|null} Mensaje de error o null si ok.
 */
function validateMovieInput(movie) {
  const { id, title, releaseDate, popularity, genres } = movie;

  if (id !== null &amp;&amp; !Number.isInteger(id)) {
    return "El ID debe ser entero.";
  }

  if (!title || title.trim().length &lt; 1 || title.trim().length > 100) {
    return "El título debe tener entre 1 y 100 caracteres.";
  }

  if (releaseDate) {
    const date = new Date(releaseDate);
    const minDate = new Date("1900-01-01");
    const today = new Date();
    if (Number.isNaN(date.getTime()) || date &lt; minDate || date > today) {
      return "La fecha de estreno debe ser válida (entre 1900 y hoy).";
    }
  }

  if (Number.isNaN(popularity) || popularity &lt; 0 || popularity > 100) {
    return "La popularidad debe estar entre 0 y 100.";
  }

  const allGenres = getGenres().map(g => g.id);
  const invalid = genres.some(gid => !allGenres.includes(gid));
  if (invalid) return "Hay géneros seleccionados que no existen.";

  return null;
}

/**
 * Guarda película nueva o actualiza existente.
 *
 * @param {{id:number|null,title:string,releaseDate:string,popularity:number,genres:number[]}} data
 * @returns {{ok:boolean,msg?:string}} Resultado de la operación.
 */
function saveOrUpdateMovieLogic(data) {
  const movies = getMovies();

  const err = validateMovieInput(data);
  if (err) return { ok: false, msg: err };

  if (data.id == null) {
    const newId = movies.length ? Math.max(...movies.map(m => m.id)) + 1 : 1;
    movies.push({
      id: newId,
      title: data.title.trim(),
      releaseDate: data.releaseDate,
      popularity: data.popularity,
      genres: data.genres,
      puntuaciones: [],
      votes: 0,
      score: "0"
    });
  } else {
    const idx = movies.findIndex(m => m.id === data.id);
    if (idx === -1) return { ok: false, msg: "Película no encontrada." };

    movies[idx].title = data.title.trim();
    movies[idx].releaseDate = data.releaseDate;
    movies[idx].popularity = data.popularity;
    movies[idx].genres = data.genres;
  }

  saveMovies(movies);
  return { ok: true };
}

/**
 * Elimina película por id.
 *
 * @param {number} id - ID de película a eliminar.
 * @returns {{ok:boolean,msg?:string}} Resultado.
 */
function deleteMovieLogic(id) {
  const movies = getMovies();
  const exists = movies.some(m => m.id === id);
  if (!exists) return { ok: false, msg: "No existe esa película." };

  saveMovies(movies.filter(m => m.id !== id));
  return { ok: true };
}

/**
 * Añade una valoración a una película y recalcula score/votos.
 *
 * @param {number} id - ID de la película.
 * @param {number} rating - Valoración entera entre 0 y 10.
 * @returns {{ok:boolean,msg?:string}} Resultado.
 */
function rateMovieLogic(id, rating) {
  const movies = getMovies();
  const movie = movies.find(m => m.id === id);
  if (!movie) return { ok: false, msg: "Película no encontrada." };

  if (!Number.isInteger(rating) || rating &lt; 0 || rating > 10) {
    return { ok: false, msg: "La valoración debe ser un entero entre 0 y 10." };
  }

  if (!Array.isArray(movie.puntuaciones)) movie.puntuaciones = [];
  movie.puntuaciones.push(rating);

  movie.votes = movie.puntuaciones.length;
  const avg = movie.puntuaciones.reduce((a, b) => a + b, 0) / movie.votes;
  movie.score = String(Math.round(avg));

  saveMovies(movies);
  return { ok: true };
}

/* ✅ Ejecutar seed al cargar lógica */
initStarWarsSeedIfEmpty();

/**
 * API pública expuesta para la capa de UI (app.js).
 */
window.CMDBLogic = {
  getGenres, saveGenres,
  getMovies, saveMovies,
  ensureUnknownGenre,
  initStarWarsSeedIfEmpty,

  addOrUpdateGenreLogic,
  deleteGenreLogic,
  saveOrUpdateMovieLogic,
  deleteMovieLogic,
  rateMovieLogic
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#GENRES_KEY">GENRES_KEY</a></li><li><a href="global.html#MOVIES_KEY">MOVIES_KEY</a></li><li><a href="global.html#OLD_GENRES_KEY">OLD_GENRES_KEY</a></li><li><a href="global.html#OLD_MOVIES_KEY">OLD_MOVIES_KEY</a></li><li><a href="global.html#addOrUpdateGenre">addOrUpdateGenre</a></li><li><a href="global.html#addOrUpdateGenreLogic">addOrUpdateGenreLogic</a></li><li><a href="global.html#clearMovieForm">clearMovieForm</a></li><li><a href="global.html#deleteGenre">deleteGenre</a></li><li><a href="global.html#deleteGenreLogic">deleteGenreLogic</a></li><li><a href="global.html#deleteMovie">deleteMovie</a></li><li><a href="global.html#deleteMovieLogic">deleteMovieLogic</a></li><li><a href="global.html#ensureUnknownGenre">ensureUnknownGenre</a></li><li><a href="global.html#fillGenresSelect">fillGenresSelect</a></li><li><a href="global.html#formatDate">formatDate</a></li><li><a href="global.html#getGenres">getGenres</a></li><li><a href="global.html#getMovies">getMovies</a></li><li><a href="global.html#initGenresPage">initGenresPage</a></li><li><a href="global.html#initListadoPage">initListadoPage</a></li><li><a href="global.html#initMoviesPage">initMoviesPage</a></li><li><a href="global.html#listGenres">listGenres</a></li><li><a href="global.html#listMovies">listMovies</a></li><li><a href="global.html#loadMovieIntoForm">loadMovieIntoForm</a></li><li><a href="global.html#migrateOldKeysIfNeeded">migrateOldKeysIfNeeded</a></li><li><a href="global.html#rateMovie">rateMovie</a></li><li><a href="global.html#rateMovieLogic">rateMovieLogic</a></li><li><a href="global.html#saveGenres">saveGenres</a></li><li><a href="global.html#saveMovies">saveMovies</a></li><li><a href="global.html#saveOrUpdateMovie">saveOrUpdateMovie</a></li><li><a href="global.html#saveOrUpdateMovieLogic">saveOrUpdateMovieLogic</a></li><li><a href="global.html#startEditGenre">startEditGenre</a></li><li><a href="global.html#validateMovieInput">validateMovieInput</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Dec 08 2025 13:16:49 GMT+0100 (hora estándar de Europa central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
